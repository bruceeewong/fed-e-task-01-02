# Part 1 Module 2 - JavaScript 内存优化

## 内存管理

- 内存：游客读写单元组成，表示一片可操作空间
- 内存管理：开发者去操作一片空间的申请、使用、释放
- 管理流程：申请-使用-释放

## 垃圾回收算法

### 引用计数算法

核心思想：设置引用数，判断当前引用数是否为０

引用计数器

引用关系改变时，修改引用数字

优点：

- 发现垃圾时，立即回收
- 最大限度减少程序暂停

缺点：

- 无法回收循环引用的对象
- 时间开销大

### 标记清除算法

核心思想: 分标记和清除两个阶段

- 遍历所有对象找标记活动的对象（活动的定义:从根节点能访问到）
- 遍历所有对象，清除没有标记的对象
- 回收相应的空间

优点：

- 可以释放无法访问的循环引用对象

缺点：

-　空间碎片化： 删除内存，地址不连续

### 标记整理

标记清除的增强

- 标注操作与标记清除一致
- 回收对象时，会整理对象位置，把活动对象移动到一起，再回收

## V8 引擎介绍

### 垃圾回收机制

#### 新生代对象回收实现

- 回收过程采用　`复制算法` + `标记整理`
- 新生代内存区分为**二个等大小的空间**
- 使用空间位`From`，空闲空间为 `To`
- 活动对象存储于`From`空间
- 标记整理后将活动对象拷贝至`To`
- `From`与`To`交换空间完成释放

细节说明

拷贝过程中可能出现**晋升**

晋升：将新生代对象移动至老生代

晋升的场景

- 一轮 GC 还存活的新生代需要晋升
- To 空间的使用率超过 25%

#### 老生代对象回收实现

算法：

- 标记清除
- 标记整理(新生代晋升空间不足时触发)
- 采用`标记清除`完成内存处理
- 采用`标记整理`进行空间优化
- 采用`增量标记`进行效率优化

#### 新老对比

新生代区域垃圾回收使用空间换时间，复制算法

老生代区域空间大，不适合复制算法

#### 增量标记

在程序运行时，分段进行遍历、标记与清除的操作。
